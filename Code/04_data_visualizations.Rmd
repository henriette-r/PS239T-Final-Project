---
title: "03_data_visualizations"
output: html_document
---

#### PS239T - An Introduction to Computational Tools and Techniques for Social Science Research
#### Henriette Ruhrmann
#### Final Project
#### April 25, 2018

# 4. Data Visualizations

_Note: This code is written to visualize the data for part (B) of my final project in which I analyze the readability of the natural language text of government websites. I use five commonly used readability indexes that provide information on the years of formal education or grade level a reader needs to have attained to be able to understand the text (the Flesch Kincaid Score, the Gunning Fog Index, the Coleman Liau Index, the SMOG Reading Formula, and the Automated_Readability_Index).

The visualizations are grouped by visualization type and not in the logical order of the presentation.

Throughout my data visualizations, I use the Viridis color package recommended to me during our student feedback round, which makes the visualizations accessible to individuals with different types of colorblindness._

## 4.1 Set Up

In this section, I am preparing my workspace for the visualization of my results from both part (A), on the structural design, and part (B), on the readability of federal government websites.

#### 4.1.1 Setting up the Environment

```{r Environment}

# Removing all objects
rm(list=ls())

# Setting the working directory
setwd(dir="/Users/HetteRiette/Desktop/PS239T-Final-Project")
getwd()

```


#### 4.1.2 Loading Packages

As in the previous subparts of my project, I used the Pacman package to efficiently install and load any new packages my code required. 

```{r Packages}
library (pacman)

# Installing and loading packages in one step with Pacman package
pacman::p_load(dplyr,
               tidyr,
               ggplot2,
               ggthemes,
               Hmisc,
               waffle,
               viridis) 
#library(dplyr)
#library(tidyr)
#library(ggplot2)
#library(ggthemes)
#library(Hmisc)
#library(waffle)
#library(viridis)

```


#### 4.1.3 Reading in the Data

In this third subpart of my project, I built directly on the results of the first and second subpart and started with the resulting dataset (for more information on the source of any of the data in the dataset, please refer to the previous code). For the purpose of the more complex pie charts, I decided to select a subset of the data containing only the relevant data. 

Moreover, I imported a dataset downloaded from IPUMS created on the 2015 American Communities Survey with a sample size of 3,147,000 individuals. To allow for faster computations, I decided to draw a random sample of 30,000 individuals.

```{r Reading the Data Files}

# Importing the main dataset created in previous subparts of my project
gov_sites     <- read.csv("/Users/HetteRiette/Desktop/PS239T-Final-Project/Data/03_text_analysis_gov_sites_df.csv")

# Creating a data frame focused only on the error reports generated by the API
api_errors    <- select(gov_sites, url, category, status, n_errors, n_lp, n_pp, error_bin)

# Importing the IPUMS dataset
ipums         <- read.csv("/Users/HetteRiette/Desktop/PS239T-Final-Project/ipums_df.csv")

# Drawing a random sample of 30,000 observations from the IPUMS dataset
ipums_sample  <- ipums[sample(nrow(ipums), 30000), ]

```


#### 4.1.4 Defining the Theme

For a consistent visual representation of my graphs, I built on the _theme_fivethirtyeight_ by manipulating certain theme elements to create the visualizations I envisioned. To improve the efficiency of my code, I bundled all added theme elements that are used for each graph. This allowed me to reduce the number of lines added to each graph by adding what are usually multiple lines of code in one line.

```{r Defining the Theme}

# Bundling common theme elements
theme_access <- theme(text = element_text(family = "Lato"),
                      plot.background = element_rect(fill = "#FFFFFF"),
                      panel.background = element_rect(fill = "#FFFFFF"),
                      legend.background = element_rect(fill = "#FFFFFF"))

```


## 4.2 Pie Charts

#### 4.2.1 Error Bins

Firstly, I focused on the type of visualization I found most challenging, pie charts, to develop my skills in this area. I had learned in our earlier data visualization exercises to create pie charts but I never mastered adding percentage labels, which substantially help to interpret the chart. Through my independent research, I learned to create assisting data frames to generate and correctly place percentage labels on the pie charts. 

```{r Pie Chart I}

# Creating assisting data frames to generate and place percentage labels
pct_er     <- data.frame(api_errors %>%
                group_by(error_bin) %>%
                tally() %>%
                mutate(pct = n / sum(n)*100))

pct_pct_er <- pct_er %>%
                mutate(error_bin = factor(error_bin, levels = error_bin[length(error_bin):1]),
                cumulative = cumsum(n),
                midpoint = cumulative - (n / 2),
                labels = paste0(round(n/sum(n)*100,1),"%"))

# Generating a pie chart illustrating the percentage of observation in pre-defined categories
pie_errors <- ggplot(pct_pct_er, aes(x="", y=pct, fill=error_bin)) +
                geom_bar(width = 1, stat = "identity") + 
                coord_polar("y")+
                geom_text(data = pct_pct_er, aes(x = 1.6, y = midpoint, label = labels), family = "Lato", size = 2, col = "#333333") +
                scale_fill_viridis(option = "viridis", discrete = T) +
                labs(title = "U.S. Federal Government Website Structural Design Errors",
                     subtitle = "Based on accessibility guidelines WCAG 2.0 (Level AA) and Section 508") +
                theme_fivethirtyeight() +
                theme_access +
                theme(text = element_text(size = 10)) +
                theme(legend.position="right") +
                theme(legend.direction="vertical") +
                theme(legend.title = element_blank()) +
                theme(panel.border = element_blank(), panel.grid=element_blank(),axis.ticks = element_blank(), axis.text.x = element_blank())

pie_errors 

# Saving using .PNG because the font type could not be found for .PDF
ggsave("pie_errors.png", plot = last_plot(), dpi = 600)

```


#### 4.2.2 Categories

My technique worked well for the first pie chart I generated, however, the same technique misplaced the percentage labels for the second pie chart by mirroring to the wrong side of the central vertical axis. While I am not sure what the source of the error was, I managed to resolve it by manually adjusting the percentage labels. 

```{r Pie Chart II}

# Creating assisting data frames to generate and place percentage labels
pct_ct <- data.frame(api_errors %>%
                group_by(category) %>%
                tally() %>%
                mutate(pct = n / sum(n)*100))

pct_pct_ct <- pct_ct %>%
                mutate(Category = factor(category, levels = category[length(category):1]),
                cumulative = cumsum(n),
                midpoint = cumulative - (n / 2),
                labels = paste0(round(n/sum(n)*100,1),"%"))

# Reassigning the wrongly placed percentage labels to their correct location
pct_pct_ct$midpoint2 <- 0
pct_pct_ct$midpoint2[pct_pct_ct$midpoint == 50.5] <- 49.5
pct_pct_ct$midpoint2[pct_pct_ct$midpoint == 95] <- 6
pct_pct_ct$midpoint2[pct_pct_ct$midpoint == 82] <- 19
pct_pct_ct$midpoint2[pct_pct_ct$midpoint == 72.5] <- 28
pct_pct_ct$midpoint2[pct_pct_ct$midpoint == 66] <- 35
pct_pct_ct$midpoint2[pct_pct_ct$midpoint == 31] <- 69.5
pct_pct_ct$midpoint2[pct_pct_ct$midpoint == 21] <- 79.5
pct_pct_ct$midpoint2[pct_pct_ct$midpoint == 14.5] <- 86
pct_pct_ct$midpoint2[pct_pct_ct$midpoint == 6] <- 94.5
pct_pct_ct$midpoint2[pct_pct_ct$midpoint == 1.5] <- 99

# Generating a pie chart illustrating the percentage of observation in pre-defined categories
pie_categories <- ggplot(pct_pct_ct, aes(x="", y=pct, fill=category)) +
                    geom_bar(width = 1, stat = "identity") +
                    coord_polar("y") +
                    geom_text(data = pct_pct_ct, aes(x = 1.6, y = midpoint2, label = labels), family = "Lato", size = 3, col = "#333333") +
                    scale_fill_viridis(option = "viridis", discrete = T) +
                    labs(title = "U.S. Federal Government Website Categories",
                         subtitle = "According to usa.gov") +
                    theme_fivethirtyeight() +
                    theme_access +
                    theme(text = element_text(size = 10)) +
                    theme(legend.position="right") +
                    theme(legend.direction="vertical") +
                    theme(legend.title = element_blank()) +
                    theme(panel.border = element_blank(), panel.grid=element_blank(),axis.ticks = element_blank(), axis.text.x = element_blank())
                    
pie_categories

# Saving using .PNG because the font type could not be found for .PDF
ggsave("pie_categories.png", plot = last_plot(), dpi = 600)

```


## 4.3 Waffle Chart

Given some of the concerns raised during our discussions of best visualization practices, I decided to also become proficient in generating waffle charts, which may be more appropriate in some situations. For this purpose, I used the Waffle package in R to create a waffle chart visualization. The waffle chart is, fortunately, a ggplot object, which allowed me to export it using the _ggsave_ command.

```{r Waffle Chart}
describe(api_errors$status)

# Assigning variable values and labels
parts <- c(`Fail` = 85, `Conditional Pass` = 2, `Pass` = (13))

# Generating a waffle chart to illustrate parts of a whole 
waffle <- waffle(parts = parts, rows = 5, colors = c("#3B578A", "#96D64C", "#F7E53D"), legend_pos = "bottom")
waffle

# Saving using .PNG because the font type could not be found for .PDF
ggsave("waffle.png", plot = last_plot(), dpi = 600)

```


## 4.4 Histograms

Through histograms using the same scale, I sought to illustrate the distribution of website readability scores and educational attainment in the U.S. population. This visualization combines the results of my data analysis with IPUMS microdata, which is why I needed to use the coding scale of the IPUMS variable. In itself, the numeric coding of the IPUMS variable is not meaningful or can easily be translated back to grade levels. For this reason, I annotated my graphs to indicate which codes correspond to the high school grade levels, which then helps the reader in identifying the pre- and post-high school stages of formal education.

#### 4.4.1 Website Readability

```{r Histogram I}

# Generating annotated histograms
hist_ws <-   ggplot(gov_sites, aes(gov_sites$adj_gl))+
                geom_rect(aes(xmin = 2.5, ymin = -Inf, xmax = 6.5, ymax = Inf), fill = "#E6E4E6", alpha = 0.1) +
                geom_histogram(binwidth = 1, aes(y = ..density..), fill = "#96D64C", color = "#DEDEDE")+
                coord_cartesian(xlim=c(0,11), ylim = c(0,0.3)) +
                scale_x_continuous(breaks = c(0:11)) +
                annotate("text", x = 4, y = 0.25, label = "High School", col = "grey", family = "Lato", size = 5) +
                labs(title = "U.S. Federal Government Website Readability Scores",
                subtitle = "Grade level converted according to IPUMS education codes") +
                xlab("Converted Grade Level")+
                ylab("")+
                theme_fivethirtyeight() +
                theme_access 
hist_ws

# Saving using .PNG because font type not found for .PDF
ggsave("hist_ws.png", plot = last_plot(), dpi = 600)

```


#### 4.4.2 U.S. Educational Attainment

```{r Histogram II}
hist_ed <-   ggplot(ipums_sample, aes(ipums_sample$EDUC))+
                geom_rect(aes(xmin = 2.5, ymin = -Inf, xmax = 6.5, ymax = Inf), fill = "#E6E4E6", alpha = 0.1) +
                geom_histogram(binwidth = 1, aes(y = ..density..), fill = "#3B578A", color = "#DEDEDE")+
                coord_cartesian(xlim=c(0,11), ylim = c(0,0.3)) +
                scale_x_continuous(breaks = c(0:11)) +
                annotate("text", x = 4, y = 0.25, label = "High School", col = "grey", family = "Lato", size = 5) +
                labs(title = "U.S. Educational Attainment",
                     subtitle = "According to IPUMS education codes") +
                xlab("Converted Grade Level")+
                ylab("")+
                theme_fivethirtyeight() +
                theme_access 
hist_ed

# Saving using .PNG because the font type could not be found for .PDF
ggsave("hist_ed.png", plot = last_plot(), dpi = 600)

```


## 4.5 Ordered Bar Chart

Moreover, I decided to use an ordered bar chart to illustrate the hierarchy of website categories based on the number of website users. Through my independent research, the most workable solution I found so far was to manually assign the ordering of the categories by creating an additional variable.

```{r Ordered Bar Chart}

# Adjusting the scale of the users variable
gov_sites$users_1000 = gov_sites$users / 1000

# Creating a variable to manually order the categories
gov_sites$category_ord <- factor(gov_sites$category, levels = c("Health", "Money and Business", "Home, Community, and Work", "Travel and Transportation", "Law Enforcement and Justice", "Benefits", "Consumer Safety", "Children and Education", "Military and Veterans", "Government Officials"))

# Generating an ordered bar chart to illustrate observation counts within categories
bar_ws <-  ggplot(gov_sites, aes(x = category_ord, y = users_1000))+
              geom_bar(stat = "identity", aes(fill=category, col = category)) +
              labs(title = "U.S. Federal Government Website User Numbers",
                   subtitle = "By Website Category") +
              xlab("") +
              ylab("Number of Users (in 1000s)")+
              theme_fivethirtyeight() +
              theme_access +
              theme(axis.title = element_text(size = 10)) +
              theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
              theme(axis.text.y = element_text(size = 7)) +
              theme(legend.text = element_blank()) +
              theme(legend.position="none") +
              theme(legend.direction="vertical") +
              scale_fill_viridis(option = "viridis", discrete = T) +
              scale_color_viridis(option = "viridis", discrete = T)
bar_ws

# Saving using .PNG because font type not found for .PDF
ggsave("bar_ws.png", plot = last_plot(), dpi = 600)

```


## 4.6 Violin Charts

#### 4.6.1 Website Readability by Category

For the first violin chart, which uses the scale of the IPUMS education variable, I decided to use the same annotation technique to illustrate the years of high school education and contrast them to the period before and after.

```{r Violin Chart I}

# Generating annotated violin charts to illustrate distributions
violin_ws <-  ggplot(gov_sites, aes(x = category, y = adj_gl)) +
                scale_x_discrete() +
                scale_y_continuous(breaks = c(0:11)) +
                geom_rect(aes(xmin = 0, xmax = 11, ymin = 3, ymax = 6), fill = "#E6E4E6", alpha = 0.1) +
                geom_violin(aes(fill=category, col = category)) +
                annotate("text", x = 2, y = 4, label = "High School", col = "grey", family = "Lato", size = 4) +
                labs(title = "U.S. Federal Government Website Readability Scores",
                     subtitle = "Grade level converted according to IPUMS education codes") +
                xlab("") +
                ylab("Converted Grade Level")+
                theme_fivethirtyeight() +
                theme_access +
                theme(axis.title = element_text(size = 10)) +
                theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                theme(axis.text.y = element_text(size = 7)) +
                theme(legend.text = element_blank()) +
                theme(legend.position="none") +
                theme(legend.direction="vertical") +
                scale_fill_viridis(option = "viridis", discrete = T) +
                scale_color_viridis(option = "viridis", discrete = T)
violin_ws

# Saving using .PNG because the font type could not be found for .PDF
ggsave("violin_ws.png", plot = last_plot(), dpi = 600)


```


#### 4.6.2 Comparison of Readability Indeces

My second violin chart to illustrate the score distributions resulting from measuring the websites' natural texts' readability with different indices required me to reformat my data from wide to long format. In particular, I needed a variable indicating the type of readability index and the resulting score, with one observation for each readability score for each website. For this purpose, I drew on our data manipulation skills learned in the first part of class to convert my dataset and create the violin chart.

Moreover, I created a second, annotated violin chart to illustrate the mean readability score across all readability indices.

```{r Violin Chart II}

# Converting the data from wide to long format
gov_sites_long <- gather(gov_sites, reading_test, score, Flesch_Kincaid:Automated_Readability_Index, factor_key = T)

# Relabeling the test names for an easily readable display in the visualization
gov_sites_long$reading_test_name <- "SMOG"
gov_sites_long$reading_test_name[gov_sites_long$reading_test == "Flesch_Kincaid"] <- "Flesch Kincaid"
gov_sites_long$reading_test_name[gov_sites_long$reading_test == "Gunning_Fog_Index"] <- "Gunning Fog Index"
gov_sites_long$reading_test_name[gov_sites_long$reading_test == "Coleman_Liau"] <- "Coleman Liau"
gov_sites_long$reading_test_name[gov_sites_long$reading_test == "Automated_Readability_Index"] <- "Automated Readability Index"

# Calculating the mean readability score
mean(gov_sites$Average_Grade_Level) # 15.49141

# Generating annotated violin charts to illustrate distributions
violin_sc <-  ggplot(gov_sites_long, aes(x = reading_test_name, y = score))+
                scale_x_discrete() +
                geom_violin(aes(fill="#E0643E", col = "#E0643E")) +
                #geom_hline(yintercept = 15.49141, color="#006837") +
                labs(title = "Comparison of Readability Scores",
                subtitle = "Across 5 common readability indices") +
                xlab("") +
                ylab("Readability Score")+
                theme_fivethirtyeight() +
                theme_access +
                theme(axis.title = element_text(size = 10)) +
                theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                theme(axis.text.y = element_text(size = 7)) +
                theme(legend.text = element_blank()) +
                theme(legend.position="none") +
                theme(legend.direction="vertical") +
                scale_fill_viridis(option = "viridis", discrete = T) +
                scale_color_viridis(option = "viridis", discrete = T)

violin_sc

# Saving using .PNG because the font type could not be found for .PDF
ggsave("violin_sc.png", plot = last_plot(), dpi = 600)

# Generating annotated violin charts to illustrate distributions
violin_sc_an <- ggplot(gov_sites_long, aes(x = reading_test_name, y = score))+
                scale_x_discrete() +
                geom_violin(aes(fill="#E0643E", col = "#E0643E")) +
                geom_hline(yintercept = 15.49141, color="#96D64C") +
                labs(title = "Comparison of Readability Scores",
                subtitle = "Across 5 common readability indices") +
                xlab("") +
                ylab("Readability Score")+
                theme_fivethirtyeight() +
                theme_access +
                theme(axis.title = element_text(size = 10)) +
                theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                theme(axis.text.y = element_text(size = 7)) +
                theme(legend.text = element_blank()) +
                theme(legend.position="none") +
                theme(legend.direction="vertical") +
                scale_fill_viridis(option = "viridis", discrete = T) +
                scale_color_viridis(option = "viridis", discrete = T)

violin_sc_an

# Saving using .PNG because the font type could not be found for .PDF
ggsave("violin_sc_an.png", plot = last_plot(), dpi = 600)

```


## 4.7 Percentiles

Finally, I sought to illustrate the comparison between website readability and U.S. educational attainment numerically and calculated the percentage of websites readable by readers who have reached up to grade level 10 and the percentage of the U.S. population who reached up to grade level 10.

```{r Percentiles}

#Calculating Percentiles
quantile(gov_sites$adj_gl, c(.06))
quantile(ipums$EDUC, c(.25))

```

